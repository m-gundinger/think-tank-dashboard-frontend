import { Project, ts, SyntaxKind } from "ts-morph";
import path from "path";
import fs from "fs/promises";
import { fileURLToPath } from "url";

// This enables source maps for debugging the script itself.
import "source-map-support/register.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const backendPath = path.resolve(__dirname, "../backend_core.txt");
const outputPath = path.resolve(__dirname, "../src/types/generated.ts");

async function main() {
  console.log("üöÄ Starting type generation from backend schemas...");

  const backendContent = await fs.readFile(backendPath, "utf-8");

  const project = new Project({
    useInMemoryFileSystem: true,
    compilerOptions: {
      allowJs: true,
      target: ts.ScriptTarget.ESNext,
    },
  });

  const sourceFile = project.createSourceFile("backend.ts", backendContent);
  const typeAliases = new Set();
  const enums = new Set();
  const exports = new Set();

  // Find all exported enums
  sourceFile.getEnums().forEach((enumDecl) => {
    if (enumDecl.isExported()) {
      enums.add(enumDecl.getText());
      exports.add(enumDecl.getName());
    }
  });

  // Find all exported types derived from Zod schemas
  sourceFile.getVariableDeclarations().forEach((varDecl) => {
    if (
      varDecl.isExported() &&
      varDecl.getInitializer()?.getText().startsWith("z.")
    ) {
      const schemaName = varDecl.getName();
      // Assumes the pattern 'export const ThingSchema = z.object(...)'
      if (schemaName.endsWith("Schema")) {
        const typeName = schemaName.replace("Schema", "");
        const typeAlias = `export type ${typeName} = z.infer<typeof ${schemaName}>;`;
        typeAliases.add(typeAlias);
        exports.add(typeName);
        exports.add(schemaName);
      }
    }
  });

  // Also grab manually defined types if they exist and are exported
  sourceFile.getTypeAliases().forEach((typeAlias) => {
    if (typeAlias.isExported()) {
      typeAliases.add(typeAlias.getText());
      exports.add(typeAlias.getName());
    }
  });

  sourceFile.getInterfaces().forEach((interfaceDecl) => {
    if (interfaceDecl.isExported()) {
      typeAliases.add(interfaceDecl.getText());
      exports.add(interfaceDecl.getName());
    }
  });

  const outputContent = `/* eslint-disable */
// @ts-nocheck
// This file is auto-generated by \`npm run gen:types\`. Do not edit manually.
import { z } from "zod";

// ---------------------
// --- ENUMERATIONS ---
// ---------------------
${[...enums].join("\n\n")}

// -----------------
// --- SCHEMAS & TYPES ---
// -----------------
${sourceFile
  .getVariableStatements()
  .filter((s) => s.isExported())
  .map((s) => s.getText())
  .join("\n\n")}

${[...typeAliases].join("\n\n")}

export {
  ${[...exports].join(",\n  ")}
};
`;

  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, outputContent);

  console.log(`‚úÖ Types successfully generated at: ${outputPath}`);
}

main().catch((err) => {
  console.error("‚ùå Type generation failed:", err);
  process.exit(1);
});
